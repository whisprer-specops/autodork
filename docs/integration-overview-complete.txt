Markdown

# OmniDork: Integration Overview

This document provides a summary of how all components in OmniDork work together to create a cohesive and powerful tool for security reconnaissance, vulnerability discovery, and quantum-enhanced search.

## Module Integration Map

┌───────────────────────────────────────────────────────────────────┐
│                           Main Program                            │
│                            (main.rs)                              │
└─────────────────┬─────────────────────────────────┬───────────────┘
│                                 │
▼                                 ▼
┌───────────────────────────────┐    ┌───────────────────────────────┐
│     OSINT & Vulnerability     │    │    Quantum Search Engine      │
│        (dork_engine.rs)       │    │        (engine.rs)            │
└────────────┬─────────┬────────┘    └────────────┬────────┬─────────┘
│         │                          │        │
▼         ▼                          ▼        ▼
┌────────────────┐ ┌────────────────┐ ┌────────────────┐ ┌────────────────┐
│ Vulnerability  │ │ Bug Bounty     │ │ Tokenizer      │ │ Entropy &      │
│ Matcher        │ │ Matcher        │ │ (tokenizer.rs) │ │ Persistence    │
│(vulnerability_matcher.rs)│ │(bug_bounty.rs) │ │                │ │ (entropy.rs)    │
└────────────────┘ └────────────────┘ └────────────────┘ └────────────────┘
▲                                  ▲
│                                  │
│         ┌────────────────┐       │
└────────►│  Web Crawler   │◄──────┘
│  (crawler.rs)  │
└────────┬───────┘
│
▼
┌────────────────┐
│ Proxy Scanner  │
│(proxy_scanner.rs)│
└────────────────┘


## Data Flow Through the System

### 1. Initialization and Target Selection

- User selects a target domain/URL and operation mode via `main.rs`.
- `main.rs` coordinates the initialization of required modules (`DorkEngine`, `VulnerabilityMatcher`, etc.).
- (Conceptual: PostgreSQL database is accessed to check for existing data - represented by structs in `lib.rs`).

### 2. OSINT Phase

- `dork_engine.rs` starts by discovering subdomains.
- Google dorks are executed against the target and subdomains.
- External services (Shodan, URLScan) are queried for additional info by `dork_engine.rs`.
- JavaScript files are extracted and analyzed by `dork_engine.rs`.
- Cloud storage resources are identified by `dork_engine.rs`.

### 3. Crawling and Indexing Phase (Used in Quantum Search & Full Scan)

- `crawler.rs` fetches content from discovered URLs.
- Raw HTML is processed to extract text and metadata by `crawler.rs`.
- Links are followed to discover additional content by `crawler.rs`.
- `proxy_scanner.rs` can conceptually provide proxies for anonymous crawling (though direct integration for this is not fully implemented, the capability exists).

### 4. Quantum Indexing Phase (Used in Quantum Search & Full Scan)

- `tokenizer.rs` creates prime-based token representations.
- `prime_hilbert.rs` builds biorthogonal vectors.
- `entropy.rs` calculates information-theoretic metrics.
- `engine.rs` manages the indexing and retrieval operations based on these representations.

### 5. Analysis Phase

- `vulnerability_matcher.rs` analyzes all collected content (from dork results, external services, JS analysis, cloud storage) for security issues.
- Regex patterns detect potential vulnerabilities using `vulnerability_matcher::analyze_content`.
- Content from JavaScript, HTTP responses, and crawled pages is correlated by `vulnerability_matcher::analyze_findings`.
- Findings are categorized by severity and type, stored in `Finding` structs.

### 6. Matching and Reporting

- `bug_bounty.rs` matches `Finding` structs to bug bounty programs.
- Potential rewards are estimated by `bug_bounty.rs`.
- Submission templates can be generated by `bug_bounty.rs`.
- Comprehensive reports (currently text-based or JSON) are created by `main.rs`.

## Key Data Structures

The following data structures, defined in `lib.rs`, allow information to flow through the system:

### 1. DorkResult

This structure represents a single result from a dork query (`dork_engine.rs`):

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DorkResult {
    pub url: String,
    pub title: String,
    pub snippet: String,
    pub content_type: Option<String>,
    pub found_dork: String,
}
2. CrawledDocument
This represents a document fetched by the crawler (crawler.rs):

Rust

#[derive(Debug, Clone)]
pub struct CrawledDocument {
    pub url: String,
    pub title: String,
    pub text: String,
}
3. ProxyInfo
This contains details about a discovered and validated proxy (proxy_scanner.rs):

Rust

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyInfo {
    pub ip: String,
    pub port: u16,
    pub protocol: String,
    pub anonymity: String,
    pub response_time: f64,
    pub country: String,
    pub last_checked: u64,
    // Additional fields from complete-proxy-scanner.rs
    pub success_rate: f32,
    pub stability_score: f32,
    pub region: Option<String>,
    pub asn: Option<String>,
}
(Note: Not all ProxyInfo fields are currently used in main.rs reporting, but are present in the struct).

4. Finding
This represents a security finding (lib.rs, populated by vulnerability_matcher.rs, etc.):

Rust

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Finding {
    pub id: String,
    pub target_id: String,
    pub subdomain_id: Option<String>,
    pub finding_type: String,
    pub severity: String,
    pub url: Option<String>,
    pub description: String,
    pub discovery_timestamp: u64,
    pub dork_used: Option<String>,
    pub screenshot_path: Option<String>, // May contain screenshot URL from services like URLScan
    pub has_sensitive_data: bool,
}
5. BountyMatch
This represents a match between a Finding and a BugBountyProgram (bug_bounty.rs):

Rust

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BountyMatch {
    pub id: String, // Added ID for consistency
    pub finding_id: String,
    pub platform: String,
    pub program_name: String,
    pub estimated_reward: Option<f64>,
    pub submission_url: Option<String>,
}
(Note: ID added to BountyMatch struct in lib.rs for consistency, although bug_bounty.rs might not fully utilize it yet).

6. PrimeVector and BiorthogonalVector
These quantum-inspired structures represent documents in the search engine (prime_hilbert.rs, used by engine.rs):

Rust

pub type PrimeVector = HashMap<u64, f64>;

#[derive(Debug, Clone)] // Added Clone derivation
pub struct BiorthogonalVector {
    pub left: PrimeVector,
    pub right: PrimeVector,
}
Integration of Quantum Concepts
The quantum aspects of OmniDork, primarily in engine.rs and supporting modules, are incorporated in these ways:

Document Representation: Documents are encoded as sparse vectors with prime number keys (tokenizer.rs, prime_hilbert.rs).
Biorthogonal Vectors: Non-Hermitian quantum mechanics inspires the left/right vector representation for enhanced scoring (prime_hilbert.rs).
Complex Resonance: Similarity scores can include both amplitude and phase components (prime_hilbert.rs).
Quantum Jumps: Feedback mechanism updates document states based on search queries to improve future relevance (engine.rs).
Persistence Theory: Thermodynamic principles model information stability and relevance for scoring (entropy.rs).
Integration of Security Features
Security functionality is integrated through:

Comprehensive Dorking: Specialized dorks for different vulnerability types are used by dork_engine.rs.
Pattern Matching: Regular expressions identify security issues in HTML, JavaScript, and other content using vulnerability_matcher.rs.
Service Integration: Shodan, URLScan, and DNS data provide additional attack surface information via dork_engine.rs.
JavaScript Analysis: Extracted scripts are analyzed for sensitive information like API keys by dork_engine.rs.
Cloud Storage Detection: Specialized dorks identify exposed cloud storage resources via dork_engine.rs.
Open Redirect Scanning: Targeted testing for open redirects is performed within main.rs.
Integration of Proxy Capabilities
Proxy functionality is integrated by:

Multi-Source Fetching: Proxies are retrieved from multiple public sources by proxy_scanner.rs.
Concurrent Validation: Asynchronous testing validates proxies efficiently using proxy_scanner.rs.
Anonymity Classification: Proxies are categorized as elite, anonymous, or transparent by proxy_scanner.rs.
Speed Testing: Performance metrics help select the fastest proxies using proxy_scanner.rs.
Crawler Integration: Validated proxies can conceptually be used by the crawler for anonymous crawling (capability exists in proxy_scanner.rs, but direct integration for this is not fully implemented).
Database Integration (Conceptual based on Structs)
OmniDork is designed to store all findings in a PostgreSQL database. The Rust structs in lib.rs define the shape of this data, aligning with a schema like the following:

SQL

CREATE TABLE targets (
    id SERIAL PRIMARY KEY,
    domain TEXT NOT NULL UNIQUE, -- Added UNIQUE constraint
    first_scan_timestamp BIGINT NOT NULL, -- Changed to BIGINT to match u64
    last_scan_timestamp BIGINT NOT NULL    -- Changed to BIGINT to match u64
);

CREATE TABLE subdomains (
    id SERIAL PRIMARY KEY,
    target_id INTEGER REFERENCES targets(id),
    subdomain TEXT NOT NULL UNIQUE, -- Added UNIQUE constraint
    first_discovered BIGINT NOT NULL, -- Changed to BIGINT
    last_seen BIGINT NOT NULL,       -- Changed to BIGINT
    ip_address TEXT,
    http_status INTEGER,
    https_enabled BOOLEAN
);

CREATE TABLE findings (
    id TEXT PRIMARY KEY, -- Changed to TEXT to match String ID
    target_id INTEGER REFERENCES targets(id),
    subdomain_id INTEGER REFERENCES subdomains(id), -- Can be NULL if not subdomain specific
    type TEXT NOT NULL,
    severity TEXT NOT NULL,
    url TEXT,
    description TEXT,
    discovery_timestamp BIGINT NOT NULL, -- Changed to BIGINT
    dork_used TEXT,
    screenshot_path TEXT,
    has_sensitive_data BOOLEAN
);

CREATE TABLE bug_bounty_matches (
    id TEXT PRIMARY KEY, -- Added ID
    finding_id TEXT REFERENCES findings(id), -- Reference to findings table
    platform TEXT NOT NULL,
    program_name TEXT NOT NULL,
    estimated_reward DOUBLE PRECISION, -- Use DOUBLE PRECISION for f64
    submission_url TEXT
);

CREATE TABLE dork_executions (
    id TEXT PRIMARY KEY, -- Added ID
    target_id INTEGER REFERENCES targets(id),
    dork TEXT NOT NULL,
    timestamp BIGINT NOT NULL, -- Changed to BIGINT
    result_count INTEGER NOT NULL
);
(Note: The lib.rs structs Target, Subdomain, BountyMatch, and DorkExecution now align with this refined schema structure, particularly the ID types and timestamp types).

Visualization Integration
OmniDork generates representations that could be used to create several types of visualizations (simulated in main.rs):

Findings Timeline: Displays the discovery of vulnerabilities over time.
Network Graph: Shows relationships between findings (conceptual).
Severity Heatmap: Shows concentration of potential vulnerabilities by severity (conceptual).
Full Integrated Workflow
A complete integrated scan (main.rs mode 5) performs these steps in sequence:

Target Selection: User enters a domain to analyze.
OSINT Gathering: dork_engine.rs discovers subdomains, executes dorks, queries external services, analyzes JS, checks cloud storage.
Vulnerability Analysis: vulnerability_matcher.rs analyzes all gathered OSINT data for security issues.
Quantum Crawling: crawler.rs indexes content, which is then processed by engine.rs into quantum representations. Seed URLs can be derived from OSINT results.
Proxy Discovery: proxy_scanner.rs finds and validates anonymous proxies.
Analysis & Correlation: While formal correlation across all data sources is complex, findings from different modules are collected into the ScanReport in main.rs.
Bug Bounty Matching: bug_bounty.rs matches discovered Finding structs to relevant programs.
Reporting: main.rs generates comprehensive reports (JSON and Markdown) and can generate conceptual visualization files.
Extension and Customization
The integrated architecture allows for easy extension:

New Dork Categories: Add specialized dorks for new vulnerability types by modifying dork_engine.rs.
Custom Regexes: Define new patterns for vulnerability detection in vulnerability_matcher.rs.
Additional APIs: Integrate with more security services by adding logic to dork_engine.rs.
Quantum Enhancements: Experiment with different quantum-inspired algorithms by modifying engine.rs, prime_hilbert.rs, entropy.rs.
Custom Proxies: Add new proxy sources or validation techniques in proxy_scanner.rs.
New Finding Types: Define new Finding types and detection logic in vulnerability_matcher.rs or helper functions in main.rs.
Resource Management
The system efficiently manages resources:

Document Compression: Compressed storage of crawled content in engine.rs.
Checkpoint System: Ability to pause and resume operations in engine.rs via saving/loading state.
Concurrent Processing: Parallel execution of tasks using Tokio across multiple modules.
Rate Limiting: Polite behavior towards search engines and APIs (simulated delays in dork_engine.rs, proxy_scanner.rs).
Memory Management: Dynamic compression of rarely-accessed data in engine.rs.
Conclusion
OmniDork's power comes from the tight integration of quantum-inspired search techniques with traditional security reconnaissance tools and proxy discovery mechanisms. This unique combination allows for more intelligent and efficient discovery of vulnerabilities, while the quantum aspects of the system provide superior search capabilities that improve with use.

The modular design makes it easy to extend and customize the system, while the shared data structures ensure that information flows smoothly between components for a unified and coherent user experience, culminating in a comprehensive ScanReport.


***

### `project-overview.md`

```markdown
# Integrated OmniDork Project

After integrating all these components, we've created a powerful tool that combines the following capabilities:

1. **OSINT and Vulnerability Scanning**
   - Subdomain discovery through various techniques (`dork_engine.rs`)
   - Google dorking with optimized patterns (`dork_engine.rs`)
   - Security service integration (Shodan, URLScan, etc.) (`dork_engine.rs`)
   - JavaScript analysis for sensitive content (`dork_engine.rs`)
   - Cloud storage detection (`dork_engine.rs`)
   - Pattern matching for security issues (`vulnerability_matcher.rs`)

2. **Quantum Resonant Search**
   - Prime-based vector representation (`tokenizer.rs`, `prime_hilbert.rs`)
   - Biorthogonal quantum-inspired scoring (`prime_hilbert.rs`, `engine.rs`)
   - Persistence theory metrics for relevance (`entropy.rs`, `engine.rs`)
   - Complex resonance with phase information (`prime_hilbert.rs`)
   - Document compression and checkpoint system (`engine.rs`)
   - Web crawling for content acquisition (`crawler.rs`)

3. **Proxy Scanner**
   - Fetch and validate proxies from multiple sources (`proxy_scanner.rs`)
   - Multi-round validation for reliability (`proxy_scanner.rs`)
   - Anonymity detection and classification (`proxy_scanner.rs`)
   - Country detection and speed measurement (`proxy_scanner.rs`)
   - Export in multiple formats (can be done from `main.rs` after scan)

4. **Open Redirect Vulnerability Scanner**
   - HTTP parameter manipulation (`main.rs`)
   - Automated payload testing (`main.rs`)
   - Response analysis for redirects (`main.rs`)
   - HTML body content inspection (conceptually, part of `main.rs` logic)

5. **Bug Bounty Integration**
   - Match findings to bug bounty programs (`bug_bounty.rs`)
   - Estimate potential rewards (`bug_bounty.rs`)
   - Generate submission templates (`bug_bounty.rs`)
   - Track submissions and status (conceptual, not fully implemented in current code)

## How It All Works Together

The system flow, orchestrated by `main.rs`, generally follows these steps in the Full Integrated Scan mode:

1. **Target Selection**: User selects a target domain or URL.
2. **Reconnaissance**: The system discovers subdomains and gathers OSINT information using `dork_engine.rs`.
3. **Analysis**: `vulnerability_matcher.rs` analyzes the gathered OSINT data for potential security findings.
4. **Quantum Crawling**: The crawler (`crawler.rs`) fetches content, which is indexed by the quantum engine (`engine.rs`).
5. **Proxy Discovery**: `proxy_scanner.rs` finds and validates anonymous proxies.
6. **Correlation & Reporting**: Findings from OSINT/Vulnerability analysis, conceptual visualizations, and bug bounty matches are collected and presented in a comprehensive `ScanReport` generated by `main.rs`. (While correlation across *all* data sources like quantum index to vulnerabilities isn't explicitly coded, the data is available in the report).
7. **Bug Bounty Matching**: `bug_bounty.rs` finds relevant bug bounty programs for the identified findings.

## Key Technical Features

- **Rust Concurrency**: Uses Tokio for asynchronous operations across modules.
- **Distributed Scanning**: Proxy rotation and concurrent operations (`proxy_scanner.rs`, `dork_engine.rs`).
- **Database Storage**: Persistent PostgreSQL schema for findings (conceptual, based on `lib.rs` structs).
- **Quantum Algorithms**: Advanced searching beyond classical methods (`engine.rs` and supporting modules).
- **Visualization**: Generation of conceptual visualization files (`main.rs`).
- **Memory Management**: Efficient compression and resource usage (`engine.rs`).

## Usage

The unified tool, run via `main.rs`, can be used in several modes:

1. **Full Integrated Scan**: Combines OSINT, vulnerability scanning, quantum search, and proxy scanning.
2. **OSINT and Vulnerability Scanning**: For reconnaissance and active security scanning without quantum search.
3. **Quantum Resonant Search**: For deep content analysis using the indexed data.
4. **Proxy Scanning**: For finding and validating proxies independently.
5. **Open Redirect Vulnerability Scan**: For targeted vulnerability scanning of provided URLs.

## Future Developments

- Machine learning for false positive reduction in vulnerability matching.
- Real-time monitoring and alerting (requires persistent storage and background processes).
- Additional vulnerability detection modules in `vulnerability_matcher.rs`.
- Distributed scanning architecture across multiple nodes.
- Expanded bug bounty platform support in `bug_bounty.rs`.
- Deeper quantum-inspired algorithmic improvements in `engine.rs`.
- Direct integration of found proxies into crawling operations.

This project represents a significant advancement by integrating traditional security scanning with quantum-inspired search algorithms and practical proxy discovery into a single, coherent tool.
