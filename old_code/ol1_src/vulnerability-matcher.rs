// src/vulnerability_matcher.rs - Optimized implementation
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::error::Error;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Mutex;
use regex::Regex;
use futures::future::join_all;
use crate::dork_engine::DorkResult;
use crate::Finding;

/// Represents a vulnerability pattern to match against content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityPattern {
    pub id: String,
    pub name: String,
    pub category: String,
    pub regex_pattern: String,
    pub severity: String,  // "Critical", "High", "Medium", "Low", "Info"
    pub platforms: Vec<String>,
    pub false_positive_checks: Vec<String>,
    pub cwe_id: Option<String>,        // Common Weakness Enumeration ID
    pub remediation: Option<String>,   // Suggested fix
}

/// Configuration for context extraction
#[derive(Debug, Clone)]
struct ContextConfig {
    before_chars: usize,  // Characters to include before match
    after_chars: usize,   // Characters to include after match
    highlight_match: bool, // Whether to highlight the matched portion
}

/// Represents a match between content and a vulnerability pattern
#[derive(Debug)]
struct VulnerabilityMatch {
    pub pattern_id: String,
    pub pattern_name: String,
    pub url: String,
    pub matched_content: String,
    pub context: String,
    pub severity: String,
    pub cwe_id: Option<String>,
    pub remediation: Option<String>,
}

/// Main vulnerability matcher for detecting security issues
pub struct VulnerabilityMatcher {
    patterns: Vec<VulnerabilityPattern>,
    compiled_regexes: HashMap<String, Regex>,
    context_config: ContextConfig,
    common_false_positives: Vec<String>,
}

impl VulnerabilityMatcher {
    /// Create a new VulnerabilityMatcher with default patterns
    pub fn new() -> Self {
        // Define default vulnerability patterns
        let patterns = vec![
            // SQL Injection patterns
            VulnerabilityPattern {
                id: "SQLI-01".to_string(),
                name: "SQL Syntax Error Disclosure".to_string(),
                category: "SQL Injection".to_string(),
                regex_pattern: r"(?i)(sql syntax|sql error|ORA-\d{5}|mysql_fetch_array\(\)|syntax error has occurred|Microsoft OLE DB Provider for SQL Server)".to_string(),
                severity: "High".to_string(),
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![
                    "documentation".to_string(),
                    "example".to_string(),
                ],
                cwe_id: Some("CWE-89".to_string()),
                remediation: Some("Implement parameterized queries or prepared statements to prevent SQL injection.".to_string()),
            },
            
            // XSS patterns
            VulnerabilityPattern {
                id: "XSS-01".to_string(),
                name: "Reflected XSS Vulnerability".to_string(),
                category: "Cross-Site Scripting".to_string(),
                regex_pattern: r"(?i)(alert\s*\(|confirm\s*\(|prompt\s*\(|<script>|javascript:)".to_string(),
                severity: "Medium".to_string(),
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![
                    "documentation".to_string(),
                    "example".to_string(),
                ],
                cwe_id: Some("CWE-79".to_string()),
                remediation: Some("Sanitize and validate all user input. Implement Content-Security-Policy headers and use frameworks that automatically escape output.".to_string()),
            },
            
            // Sensitive data exposure
            VulnerabilityPattern {
                id: "EXPOSURE-01".to_string(),
                name: "API Key Exposure".to_string(),
                category: "Sensitive Data Exposure".to_string(),
                regex_pattern: r"(?i)(api_key|apikey|api-key|access_token|secret_key|password)\s*[:=]\s*['\"]([\w\-\.]{10,})['\"]\s*".to_string(),
                severity: "Critical".to_string(),
                platforms: vec!["Web".to_string(), "Mobile".to_string()],
                false_positive_checks: vec![
                    "placeholder".to_string(),
                    "example".to_string(),
                    "YOUR_API_KEY".to_string(),
                ],
                cwe_id: Some("CWE-312".to_string()),
                remediation: Some("Never store sensitive credentials in client-side code. Use environment variables or secure credential storage.".to_string()),
            },
            
            // Open redirect
            VulnerabilityPattern {
                id: "REDIRECT-01".to_string(),
                name: "Open Redirect Vulnerability".to_string(),
                category: "Open Redirect".to_string(),
                regex_pattern: r"(?i)(redirect|redir|url|link|goto|return_to)\s*=\s*(https?:\/\/|\/\/|\.\.\/|\/)".to_string(),
                severity: "Medium".to_string(),
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![],
                cwe_id: Some("CWE-601".to_string()),
                remediation: Some("Implement a whitelist of allowed redirect destinations and validate all redirect URLs against this list.".to_string()),
            },
            
            // Admin interfaces
            VulnerabilityPattern {
                id: "ADMIN-01".to_string(),
                name: "Exposed Admin Interface".to_string(),
                category: "Information Disclosure".to_string(),
                regex_pattern: r"(?i)(admin|administrator|administration|login|backend|cpanel|wp-admin)".to_string(),
                severity: "Medium".to_string(),
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![],
                cwe_id: Some("CWE-200".to_string()),
                remediation: Some("Restrict access to administrative interfaces with proper authentication and IP restrictions.".to_string()),
            },
            
            // Error disclosure
            VulnerabilityPattern {
                id: "ERROR-01".to_string(),
                name: "Detailed Error Messages".to_string(),
                category: "Information Disclosure".to_string(),
                regex_pattern: r"(?i)(exception|stack trace|debug info|error in|undefined index|fatal error)".to_string(),
                severity: "Low".to_string(),
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![
                    "documentation".to_string(),
                ],
                cwe_id: Some("CWE-209".to_string()),
                remediation: Some("Configure proper error handling to display generic error messages to users while logging detailed errors for administrators.".to_string()),
            },
            
            // CORS misconfiguration
            VulnerabilityPattern {
                id: "CORS-01".to_string(),
                name: "CORS Misconfiguration".to_string(),
                category: "Security Misconfiguration".to_string(),
                regex_pattern: r"(?i)(Access-Control-Allow-Origin:\s*\*)".to_string(),
                severity: "Medium".to_string(),
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![],
                cwe_id: Some("CWE-942".to_string()),
                remediation: Some("Configure CORS headers with specific origins instead of using wildcards.".to_string()),
            },
            
            // JWT exposure
            VulnerabilityPattern {
                id: "JWT-01".to_string(),
                name: "JWT Token Exposure".to_string(),
                category: "Sensitive Data Exposure".to_string(),
                regex_pattern: r"eyJ[a-zA-Z0-9_-]{5,}\.eyJ[a-zA-Z0-9_-]{5,}\.[a-zA-Z0-9_-]{5,}".to_string(),
                severity: "High".to_string(),
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![
                    "example".to_string(),
                ],
                cwe_id: Some("CWE-522".to_string()),
                remediation: Some("Do not expose JWTs in client-side code or URLs. Store tokens securely using httpOnly cookies.".to_string()),
            },
        ];
        
        // Compile regexes
        let mut compiled_regexes = HashMap::new();
        for pattern in &patterns {
            match Regex::new(&pattern.regex_pattern) {
                Ok(regex) => {
                    compiled_regexes.insert(pattern.id.clone(), regex);
                },
                Err(e) => {
                    eprintln!("Failed to compile regex pattern for {}: {}", pattern.id, e);
                }
            }
        }
        
        // Default context configuration
        let context_config = ContextConfig {
            before_chars: 50,
            after_chars: 50,
            highlight_match: true,
        };
        
        // Common false positive strings
        let common_false_positives = vec![
            "documentation".to_string(),
            "example".to_string(),
            "tutorial".to_string(),
            "sample".to_string(),
            "test".to_string(),
            "placeholder".to_string(),
        ];
        
        VulnerabilityMatcher {
            patterns,
            compiled_regexes,
            context_config,
            common_false_positives,
        }
    }

    /// Analyze content for vulnerabilities with improved context extraction
    pub fn analyze_content(&self, url: &str, content: &str) -> Vec<VulnerabilityMatch> {
        let mut matches = Vec::new();
        
        for pattern in &self.patterns {
            if let Some(regex) = self.compiled_regexes.get(&pattern.id) {
                for cap in regex.captures_iter(content) {
                    if let Some(matched) = cap.get(0) {
                        // Extract context around the match
                        let context = self.extract_context(content, matched.start(), matched.end());
                        
                        // Check for false positives
                        if !self.is_false_positive(&pattern.false_positive_checks, &context, pattern, url) {
                            matches.push(VulnerabilityMatch {
                                pattern_id: pattern.id.clone(),
                                pattern_name: pattern.name.clone(),
                                url: url.to_string(),
                                matched_content: matched.as_str().to_string(),
                                context,
                                severity: pattern.severity.clone(),
                                cwe_id: pattern.cwe_id.clone(),
                                remediation: pattern.remediation.clone(),
                            });
                        }
                    }
                }
            }
        }
        
        matches
    }
    
    /// Extract context around a match with smarter boundary detection
    fn extract_context(&self, content: &str, match_start: usize, match_end: usize) -> String {
        // Determine context boundaries with sentence awareness
        let context_start = if match_start < self.context_config.before_chars {
            0
        } else {
            // Try to start at sentence or line boundary
            let text_before = &content[match_start - self.context_config.before_chars..match_start];
            if let Some(pos) = text_before.rfind(|c| c == '.' || c == '!' || c == '?' || c == '\n') {
                match_start - self.context_config.before_chars + pos + 1
            } else {
                match_start - self.context_config.before_chars
            }
        };
        
        let context_end = if match_end + self.context_config.after_chars >= content.len() {
            content.len()
        } else {
            // Try to end at sentence or line boundary
            let text_after = &content[match_end..match_end + self.context_config.after_chars];
            if let Some(pos) = text_after.find(|c| c == '.' || c == '!' || c == '?' || c == '\n') {
                match_end + pos + 1
            } else {
                match_end + self.context_config.after_chars
            }
        };
        
        // Extract the context
        let mut context = content[context_start..context_end].to_string();
        
        // Optionally highlight the match
        if self.context_config.highlight_match {
            let relative_start = match_start - context_start;
            let relative_end = match_end - context_start;
            
            // Only highlight if the indices are valid for the extracted context
            if relative_start < context.len() && relative_end <= context.len() {
                let before = &context[..relative_start];
                let matched = &context[relative_start..relative_end];
                let after = &context[relative_end..];
                context = format!("{}[MATCH: {}]{}", before, matched, after);
            }
        }
        
        context
    }
    
    /// Check if a match is a false positive
    fn is_false_positive(&self, pattern_checks: &[String], context: &str, pattern: &VulnerabilityPattern, url: &str) -> bool {
        // Check pattern-specific false positive indicators
        let lower_context = context.to_lowercase();
        
        for check in pattern_checks {
            if lower_context.contains(&check.to_lowercase()) {
                return true;
            }
        }
        
        // Check common false positives
        for check in &self.common_false_positives {
            if lower_context.contains(&check.to_lowercase()) {
                // For critical findings, be more strict about false positives
                if pattern.severity != "Critical" {
                    return true;
                }
            }
        }
        
        // Special case for API keys - check for common placeholders
        if pattern.id.starts_with("EXPOSURE") {
            let api_key_placeholders = [
                "your_api_key", "apikey_here", "insert_api_key",
                "xxxxxxxxxxxxxxxx", "0000000000000000", "api_key_value",
            ];
            
            for placeholder in &api_key_placeholders {
                if lower_context.contains(placeholder) {
                    return true;
                }
            }
        }
        
        // Check URL for indications of documentation or test sites
        let lower_url = url.to_lowercase();
        
        if lower_url.contains("docs") || 
           lower_url.contains("documentation") || 
           lower_url.contains("example") || 
           lower_url.contains("test") || 
           lower_url.contains("sample") {
            return true;
        }
        
        false
    }

    /// Update vulnerability patterns from GitHub
    pub async fn update_patterns_from_github(&mut self) -> Result<(), Box<dyn Error>> {
        println!("Updating vulnerability patterns from GitHub...");
        
        // In a real implementation, this would fetch patterns from a GitHub repository
        // For now, we simulate a delay
        tokio::time::sleep(Duration::from_millis(500)).await;
        
        println!("Vulnerability patterns updated successfully");
        
        Ok(())
    }

    /// Analyze findings from various sources with parallel processing
    pub async fn analyze_findings(
        &self,
        target: &str,
        dork_results: &[DorkResult],
        shodan_results: &[serde_json::Value],
        urlscan_results: &[serde_json::Value],
        dns_information: &[serde_json::Value],
        js_analysis: &[serde_json::Value],
        cloud_storage: &[serde_json::Value],
    ) -> Result<Vec<Finding>, Box<dyn Error>> {
        println!("Analyzing findings from multiple sources...");
        
        // Create a thread-safe collection for findings
        let findings = Arc::new(Mutex::new(Vec::new()));
        
        // Process different data sources in parallel
        let mut tasks = Vec::new();
        
        // Process dork results
        tasks.push(tokio::spawn({
            let findings = Arc::clone(&findings);
            let target = target.to_string();
            async move {
                process_dork_results(&target, dork_results, findings).await;
            }
        }));
        
        // Process JavaScript analysis
        tasks.push(tokio::spawn({
            let findings = Arc::clone(&findings);
            let target = target.to_string();
            async move {
                process_js_analysis(&target, js_analysis, findings).await;
            }
        }));
        
        // Process Shodan results
        tasks.push(tokio::spawn({
            let findings = Arc::clone(&findings);
            let target = target.to_string();
            async move {
                process_shodan_results(&target, shodan_results, findings).await;
            }
        }));
        
        // Process URLScan results
        tasks.push(tokio::spawn({
            let findings = Arc::clone(&findings);
            let target = target.to_string();
            async move {
                process_urlscan_results(&target, urlscan_results, findings).await;
            }
        }));
        
        // Process DNS information
        tasks.push(tokio::spawn({
            let findings = Arc::clone(&findings);
            let target = target.to_string();
            async move {
                process_dns_information(&target, dns_information, findings).await;
            }
        }));
        
        // Process cloud storage findings
        tasks.push(tokio::spawn({
            let findings = Arc::clone(&findings);
            let target = target.to_string();
            async move {
                process_cloud_storage(&target, cloud_storage, findings).await;
            }
        }));
        
        // Wait for all tasks to complete
        for task in tasks {
            let _ = task.await;
        }
        
        // Extract and sort findings by severity
        let mut result = Arc::try_unwrap(findings)
            .unwrap_or_else(|_| panic!("Failed to unwrap Arc"))
            .into_inner();
        
        // Sort by severity (Critical -> High -> Medium -> Low -> Info)
        result.sort_by(|a, b| {
            let a_severity = convert_severity_to_numeric(&a.severity);
            let b_severity = convert_severity_to_numeric(&b.severity);
            b_severity.cmp(&a_severity)
        });
        
        // Deduplicate findings by combining similar ones
        let result = self.deduplicate_findings(result);
        
        println!("Analysis complete. Found {} unique findings", result.len());
        
        Ok(result)
    }
    
    /// Deduplicate and merge similar findings
    fn deduplicate_findings(&self, findings: Vec<Finding>) -> Vec<Finding> {
        let mut unique_findings = Vec::new();
        let mut seen_urls = HashMap::new();
        
        for finding in findings {
            if let Some(url) = &finding.url {
                if let Some(existing_idx) = seen_urls.get(url) {
                    // Combine descriptions for similar findings at the same URL
                    if finding.finding_type == unique_findings[*existing_idx].finding_type {
                        let existing = &mut unique_findings[*existing_idx];
                        let combined_desc = format!("{}\n\nAdditional information: {}", 
                                                existing.description, finding.description);
                        existing.description = combined_desc;
                        
                        // Take the higher severity
                        if convert_severity_to_numeric(&finding.severity) > 
                           convert_severity_to_numeric(&existing.severity) {
                            existing.severity = finding.severity;
                        }
                        
                        continue;
                    }
                }
                seen_urls.insert(url.clone(), unique_findings.len());
            }
            unique_findings.push(finding);
        }
        
        unique_findings
    }
}

// Helper function to process dork results
async fn process_dork_results(
    target: &str,
    dork_results: &[DorkResult],
    findings: Arc<Mutex<Vec<Finding>>>
) {
    // Process each dork result
    for (i, result) in dork_results.iter().enumerate() {
        // Check URL for vulnerabilities
        if result.url.contains("admin") || 
           result.url.contains("login") || 
           result.url.contains("dashboard") || 
           result.url.contains("wp-admin") {
            let mut findings_lock = findings.lock().await;
            findings_lock.push(Finding {
                id: format!("FINDING-DORK-URL-{}", i),
                target_id: target.to_string(),
                subdomain_id: None,
                finding_type: "Exposed Admin Interface".to_string(),
                severity: "Medium".to_string(),
                url: Some(result.url.clone()),
                description: format!(
                    "Potential administrative interface discovered at {}. Admin interfaces should be properly secured and not easily discoverable through search engines.",
                    result.url
                ),
                discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                dork_used: Some(result.found_dork.clone()),
                screenshot_path: None,
                has_sensitive_data: false,
            });
        }
        
        // Check for configuration files
        if result.url.contains(".env") || 
           result.url.contains(".config") || 
           result.url.contains(".conf") || 
           result.url.contains("config.") || 
           result.url.contains("settings.") {
            let mut findings_lock = findings.lock().await;
            findings_lock.push(Finding {
                id: format!("FINDING-DORK-CONFIG-{}", i),
                target_id: target.to_string(),
                subdomain_id: None,
                finding_type: "Exposed Configuration File".to_string(),
                severity: "High".to_string(),
                url: Some(result.url.clone()),
                description: format!(
                    "Configuration file potentially exposed at {}. These files often contain sensitive information like database credentials or API keys.",
                    result.url
                ),
                discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                dork_used: Some(result.found_dork.clone()),
                screenshot_path: None,
                has_sensitive_data: true,
            });
        }
        
        // Check snippet for vulnerabilities
        if result.snippet.contains("error") || 
           result.snippet.contains("exception") || 
           result.snippet.contains("SQL syntax") {
            let mut findings_lock = findings.lock().await;
            findings_lock.push(Finding {
                id: format!("FINDING-DORK-SNIPPET-{}", i),
                target_id: target.to_string(),
                subdomain_id: None,
                finding_type: "Error Disclosure".to_string(),
                severity: "Medium".to_string(),
                url: Some(result.url.clone()),
                description: format!(
                    "Error message disclosed in search results: '{}'. Detailed error messages can reveal sensitive implementation details that help attackers formulate exploits.",
                    result.snippet
                ),
                discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                dork_used: Some(result.found_dork.clone()),
                screenshot_path: None,
                has_sensitive_data: false,
            });
        }
        
        // Check for backup files
        if result.url.contains(".bak") || 
           result.url.contains(".backup") || 
           result.url.contains(".old") || 
           result.url.contains(".temp") || 
           result.url.contains("~") {
            let mut findings_lock = findings.lock().await;
            findings_lock.push(Finding {
                id: format!("FINDING-DORK-BACKUP-{}", i),
                target_id: target.to_string(),
                subdomain_id: None,
                finding_type: "Exposed Backup File".to_string(),
                severity: "Medium".to_string(),
                url: Some(result.url.clone()),
                description: format!(
                    "Potential backup file discovered at {}. These files may contain outdated but sensitive information and should not be publicly accessible.",
                    result.url
                ),
                discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                dork_used: Some(result.found_dork.clone()),
                screenshot_path: None,
                has_sensitive_data: true,
            });
        }
    }
}

// Helper function to process JavaScript analysis
async fn process_js_analysis(
    target: &str,
    js_analysis: &[serde_json::Value],
    findings: Arc<Mutex<Vec<Finding>>>
) {
    // Process each JavaScript analysis result
    for (i, js_result) in js_analysis.iter().enumerate() {
        // Check for API keys
        if let Some(api_keys) = js_result.get("api_keys").and_then(|k| k.as_array()) {
            if !api_keys.is_empty() {
                let mut findings_lock = findings.lock().await;
                findings_lock.push(Finding {
                    id: format!("FINDING-JS-API-KEYS-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "API Key Exposure".to_string(),
                    severity: "High".to_string(),
                    url: js_result.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                    description: format!(
                        "API keys found in JavaScript file that could be used to access protected APIs. This could lead to unauthorized access, data exposure, or potential service abuse: {:?}\n\nRecommendation: Never store sensitive credentials in client-side code. Use environment variables or secure credential storage.",
                        api_keys
                    ),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: None,
                    screenshot_path: None,
                    has_sensitive_data: true,
                });
            }
        }
        
        // Check for endpoints
        if let Some(endpoints) = js_result.get("endpoints").and_then(|e| e.as_array()) {
            if !endpoints.is_empty() {
                let mut findings_lock = findings.lock().await;
                findings_lock.push(Finding {
                    id: format!("FINDING-JS-ENDPOINTS-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "API Endpoint Disclosure".to_string(),
                    severity: "Low".to_string(),
                    url: js_result.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                    description: format!(
                        "API endpoints discovered in JavaScript that could potentially be accessed without proper authentication. This information can help attackers understand the application's API structure: {:?}\n\nRecommendation: Ensure all API endpoints have proper authentication and authorization checks.",
                        endpoints
                    ),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: None,
                    screenshot_path: None,
                    has_sensitive_data: false,
                });
            }
        }
        
        // Check for hard-coded credentials
        if let Some(true) = js_result.get("has_credentials").and_then(|c| c.as_bool()) {
            let mut findings_lock = findings.lock().await;
            findings_lock.push(Finding {
                id: format!("FINDING-JS-CREDENTIALS-{}", i),
                target_id: target.to_string(),
                subdomain_id: None,
                finding_type: "Hard-coded Credentials".to_string(),
                severity: "Critical".to_string(),
                url: js_result.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                description: "Hard-coded credentials found in JavaScript code. These credentials can be extracted and used to gain unauthorized access to systems.\n\nRecommendation: Remove all hard-coded credentials from client-side code and use secure authentication mechanisms.".to_string(),
                discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                dork_used: None,
                screenshot_path: None,
                has_sensitive_data: true,
            });
        }
    }
}

// Helper function to process Shodan results
async fn process_shodan_results(
    target: &str,
    shodan_results: &[serde_json::Value],
    findings: Arc<Mutex<Vec<Finding>>>
) {
    // Process each Shodan result
    for (i, shodan_result) in shodan_results.iter().enumerate() {
        // Check for vulnerabilities
        if let Some(vulns) = shodan_result.get("vulns").and_then(|v| v.as_object()) {
            if !vulns.is_empty() {
                let mut findings_lock = findings.lock().await;
                findings_lock.push(Finding {
                    id: format!("FINDING-SHODAN-VULNS-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "Known Vulnerabilities".to_string(),
                    severity: "High".to_string(),
                    url: shodan_result.get("ip_str").and_then(|ip| ip.as_str()).map(|ip| format!("http://{}", ip)),
                    description: format!(
                        "Known vulnerabilities detected by Shodan that could be exploited. Update or patch affected systems immediately: {:?}",
                        vulns.keys().collect::<Vec<_>>()
                    ),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: None,
                    screenshot_path: None,
                    has_sensitive_data: false,
                });
            }
        }
        
        // Check for open ports
        if let Some(ports) = shodan_result.get("ports").and_then(|p| p.as_array()) {
            let has_unusual_ports = ports.iter().any(|p| {
                if let Some(port_num) = p.as_u64() {
                    match port_num {
                        22 | 80 | 443 => false, // Common ports
                        _ => true, // Unusual ports
                    }
                } else {
                    false
                }
            });
            
            if has_unusual_ports {
                let mut findings_lock = findings.lock().await;
                findings_lock.push(Finding {
                    id: format!("FINDING-SHODAN-PORTS-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "Unusual Open Ports".to_string(),
                    severity: "Medium".to_string(),
                    url: shodan_result.get("ip_str").and_then(|ip| ip.as_str()).map(|ip| format!("http://{}", ip)),
                    description: format!(
                        "Unusual open ports detected that could expose vulnerable services or provide unauthorized access paths. Consider restricting access to necessary ports only: {:?}",
                        ports
                    ),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: None,
                    screenshot_path: None,
                    has_sensitive_data: false,
                });
            }
        }
    }
}

// Helper function to process URLScan results
async fn process_urlscan_results(
    target: &str,
    urlscan_results: &[serde_json::Value],
    findings: Arc<Mutex<Vec<Finding>>>
) {
    // Process each URLScan result
    for (i, urlscan_result) in urlscan_results.iter().enumerate() {
        // Check for security-related headers
        if let Some(page) = urlscan_result.get("page") {
            let missing_security_headers = vec![
                "Content-Security-Policy",
                "X-XSS-Protection",
                "X-Content-Type-Options",
                "X-Frame-Options",
                "Strict-Transport-Security",
                "Referrer-Policy",
                "Permissions-Policy",
            ];
            
            let mut missing_headers = Vec::new();
            
            for header in &missing_security_headers {
                if !page.get(header).is_some() {
                    missing_headers.push(header.to_string());
                }
            }
            
            if !missing_headers.is_empty() {
                let mut findings_lock = findings.lock().await;
                findings_lock.push(Finding {
                    id: format!("FINDING-URLSCAN-HEADERS-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "Missing Security Headers".to_string(),
                    severity: "Low".to_string(),
                    url: page.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                    description: format!(
                        "Security headers are missing that could help protect against common web vulnerabilities like XSS, clickjacking, and MIME sniffing: {:?}. Implementing these headers adds important defense-in-depth protections.",
                        missing_headers
                    ),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: None,
                    screenshot_path: None,
                    has_sensitive_data: false,
                });
            }
            
            // Check for insecure content
            if let Some(true) = page.get("hasInsecureContent").and_then(|v| v.as_bool()) {
                let mut findings_lock = findings.lock().await;
                findings_lock.push(Finding {
                    id: format!("FINDING-URLSCAN-MIXED-CONTENT-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "Mixed Content".to_string(),
                    severity: "Medium".to_string(),
                    url: page.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                    description: "The page loads resources over insecure HTTP connections, which can lead to man-in-the-middle attacks. All resources should be loaded over HTTPS.".to_string(),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: None,
                    screenshot_path: None,
                    has_sensitive_data: false,
                });
            }
        }
    }
}

// Helper function to process DNS information
async fn process_dns_information(
    target: &str,
    dns_information: &[serde_json::Value],
    findings: Arc<Mutex<Vec<Finding>>>
) {
    // Process each DNS information result
    for (i, dns_result) in dns_information.iter().enumerate() {
        // Check SPF records
        if let Some(records) = dns_result.get("records").and_then(|r| r.as_object()) {
            if let Some(txt_records) = records.get("TXT").and_then(|t| t.as_array()) {
                let has_spf = txt_records.iter().any(|r| {
                    r.as_str().map_or(false, |s| s.contains("v=spf1"))
                });
                
                if !has_spf {
                    let mut findings_lock = findings.lock().await;
                    findings_lock.push(Finding {
                        id: format!("FINDING-DNS-SPF-{}", i),
                        target_id: target.to_string(),
                        subdomain_id: None,
                        finding_type: "Missing SPF Record".to_string(),
                        severity: "Low".to_string(),
                        url: None,
                        description: format!(
                            "Domain {} is missing an SPF record, which may lead to email spoofing. SPF records help prevent unauthorized senders from using your domain to send emails, reducing spam and phishing attempts.",
                            dns_result.get("domain").and_then(|d| d.as_str()).unwrap_or(target)
                        ),
                        discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                        dork_used: None,
                        screenshot_path: None,
                        has_sensitive_data: false,
                    });
                }
                
                // Check DMARC records
                let has_dmarc = txt_records.iter().any(|r| {
                    r.as_str().map_or(false, |s| s.contains("v=DMARC1"))
                });
                
                if !has_dmarc {
                    let mut findings_lock = findings.lock().await;
                    findings_lock.push(Finding {
                        id: format!("FINDING-DNS-DMARC-{}", i),
                        target_id: target.to_string(),
                        subdomain_id: None,
                        finding_type: "Missing DMARC Record".to_string(),
                        severity: "Low".to_string(),
                        url: None,
                        description: format!(
                            "Domain {} is missing a DMARC record, which helps protect against email spoofing and phishing. DMARC works with SPF and DKIM to provide stronger email authentication.",
                            dns_result.get("domain").and_then(|d| d.as_str()).unwrap_or(target)
                        ),
                        discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                        dork_used: None,
                        screenshot_path: None,
                        has_sensitive_data: false,
                    });
                }
            }
            
            // Check for DNSSEC
            let has_dnssec = records.get("DNSKEY").is_some() || records.get("DS").is_some();
            
            if !has_dnssec {
                let mut findings_lock = findings.lock().await;
                findings_lock.push(Finding {
                    id: format!("FINDING-DNS-DNSSEC-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "DNSSEC Not Enabled".to_string(),
                    severity: "Low".to_string(),
                    url: None,
                    description: format!(
                        "Domain {} does not have DNSSEC enabled, which makes it vulnerable to DNS spoofing and cache poisoning attacks. DNSSEC adds cryptographic signatures to DNS records to ensure their authenticity.",
                        dns_result.get("domain").and_then(|d| d.as_str()).unwrap_or(target)
                    ),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: None,
                    screenshot_path: None,
                    has_sensitive_data: false,
                });
            }
        }
    }
}

// Helper function to process cloud storage findings
async fn process_cloud_storage(
    target: &str,
    cloud_storage: &[serde_json::Value],
    findings: Arc<Mutex<Vec<Finding>>>
) {
    // Process each cloud storage finding
    for (i, storage_result) in cloud_storage.iter().enumerate() {
        // All cloud storage findings are potentially sensitive
        let mut findings_lock = findings.lock().await;
        findings_lock.push(Finding {
            id: format!("FINDING-CLOUD-STORAGE-{}", i),
            target_id: target.to_string(),
            subdomain_id: None,
            finding_type: "Cloud Storage Exposure".to_string(),
            severity: "Medium".to_string(),
            url: storage_result.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
            description: format!(
                "Exposed cloud storage found: {} ({}). Publicly accessible cloud storage can lead to data leaks if it contains sensitive information. Consider restricting access controls or making the bucket private.", 
                storage_result.get("title").and_then(|t| t.as_str()).unwrap_or("Unknown"),
                storage_result.get("storage_type").and_then(|t| t.as_str()).unwrap_or("Unknown")
            ),
            discovery_timestamp: chrono::Utc::now().timestamp() as u64,
            dork_used: None,
            screenshot_path: None,
            has_sensitive_data: true,
        });
    }
}

/// Helper function to convert severity string to numeric value for sorting
fn convert_severity_to_numeric(severity: &str) -> u8 {
    match severity.to_lowercase().as_str() {
        "critical" => 4,
        "high" => 3,
        "medium" => 2,
        "low" => 1,
        "info" | "informational" => 0,
        _ => 0, // Default for unknown severity
    }
}

/// Helper function to extract domain from URL
fn extract_domain(url: &str) -> Option<&str> {
    // Simple domain extraction - would use a proper URL parser in production
    if let Some(host_start) = url.find("://") {
        let host_part = &url[host_start + 3..];
        if let Some(path_start) = host_part.find('/') {
            return Some(&host_part[..path_start]);
        } else {
            return Some(host_part);
        }
    }
    None
}

// Add tokio sleep for async delay
async fn sleep(duration: Duration) {
    tokio::time::sleep(duration).await;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_analyze_content() {
        let matcher = VulnerabilityMatcher::new();
        
        // Test SQL injection detection
        let content = "This page has an error: SQL syntax error near 'WHERE'";
        let url = "https://example.com/page";
        
        let matches = matcher.analyze_content(url, content);
        assert!(!matches.is_empty());
        assert_eq!(matches[0].pattern_id, "SQLI-01");
        
        // Test false positive detection
        let documentation = "Example of SQL syntax error in documentation: SQL syntax error near 'WHERE'";
        let matches = matcher.analyze_content(url, documentation);
        assert!(matches.is_empty());
    }
    
    #[test]
    fn test_extract_context() {
        let matcher = VulnerabilityMatcher::new();
        
        let content = "This is a test with a vulnerability in the middle and some more text after it.";
        let match_start = 24; // "vulnerability" starts at position 24
        let match_end = 36; // "vulnerability" ends at position 36
        
        let context = matcher.extract_context(content, match_start, match_end);
        assert!(context.contains("vulnerability"));
        assert!(context.len() <= matcher.context_config.before_chars + matcher.context_config.after_chars + (match_end - match_start));
    }
    
    #[test]
    fn test_is_false_positive() {
        let matcher = VulnerabilityMatcher::new();
        
        // Test pattern-specific check
        let pattern_checks = vec!["example".to_string()];
        let context = "This is an example of SQL injection";
        let pattern = &matcher.patterns[0]; // SQL injection pattern
        
        assert!(matcher.is_false_positive(&pattern_checks, context, pattern, "example.com"));
        
        // Test non-false positive
        let context = "This is a real SQL injection vulnerability";
        assert!(!matcher.is_false_positive(&pattern_checks, context, pattern, "example.com"));
    }
    
    #[tokio::test]
    async fn test_process_dork_results() {
        let target = "example.com";
        let dork_results = vec![
            DorkResult {
                url: "https://example.com/admin".to_string(),
                title: "Admin Panel".to_string(),
                snippet: "Login to the admin panel".to_string(),
                content_type: None,
                found_dork: "site:example.com inurl:admin".to_string(),
            }
        ];
        
        let findings = Arc::new(Mutex::new(Vec::new()));
        
        process_dork_results(target, &dork_results, findings.clone()).await;
        
        let result = Arc::try_unwrap(findings).unwrap().into_inner();
        assert!(!result.is_empty());
        assert_eq!(result[0].finding_type, "Exposed Admin Interface");
    }
    
    #[tokio::test]
    async fn test_process_js_analysis() {
        let target = "example.com";
        let js_analysis = vec![
            serde_json::json!({
                "url": "https://example.com/app.js",
                "api_keys": [
                    {
                        "type": "api_key",
                        "value": "abcdef1234567890"
                    }
                ]
            })
        ];
        
        let findings = Arc::new(Mutex::new(Vec::new()));
        
        process_js_analysis(target, &js_analysis, findings.clone()).await;
        
        let result = Arc::try_unwrap(findings).unwrap().into_inner();
        assert!(!result.is_empty());
        assert_eq!(result[0].finding_type, "API Key Exposure");
    }
    
    #[tokio::test]
    async fn test_severity_sorting() {
        let findings = vec![
            Finding {
                id: "1".to_string(),
                target_id: "example.com".to_string(),
                subdomain_id: None,
                finding_type: "Low Priority".to_string(),
                severity: "Low".to_string(),
                url: None,
                description: "Low severity finding".to_string(),
                discovery_timestamp: 0,
                dork_used: None,
                screenshot_path: None,
                has_sensitive_data: false,
            },
            Finding {
                id: "2".to_string(),
                target_id: "example.com".to_string(),
                subdomain_id: None,
                finding_type: "Critical Priority".to_string(),
                severity: "Critical".to_string(),
                url: None,
                description: "Critical severity finding".to_string(),
                discovery_timestamp: 0,
                dork_used: None,
                screenshot_path: None,
                has_sensitive_data: false,
            }
        ];
        
        // Sort by severity
        let mut sorted = findings.clone();
        sorted.sort_by(|a, b| {
            let a_severity = convert_severity_to_numeric(&a.severity);
            let b_severity = convert_severity_to_numeric(&b.severity);
            b_severity.cmp(&a_severity)
        });
        
        // First finding should be Critical
        assert_eq!(sorted[0].severity, "Critical");
    }
    
    #[test]
    fn test_extract_domain() {
        assert_eq!(extract_domain("https://example.com/path"), Some("example.com"));
        assert_eq!(extract_domain("http://sub.example.com"), Some("sub.example.com"));
        assert_eq!(extract_domain("example.com"), None); // No scheme
    }
}
