// src/vulnerability_matcher.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::error::Error;
use regex::Regex;
use crate::dork_engine::DorkResult;
use crate::Finding;

/// Represents a vulnerability pattern to match against content
#[derive(Debug, Serialize, Deserialize)]
pub struct VulnerabilityPattern {
    pub id: String,
    pub name: String,
    pub category: String,
    pub regex_pattern: String,
    pub severity: u8,  // 1-5, where 5 is most severe
    pub platforms: Vec<String>,
    pub false_positive_checks: Vec<String>,
}

/// Represents a match between content and a vulnerability pattern
#[derive(Debug)]
struct VulnerabilityMatch {
    pub pattern_id: String,
    pub pattern_name: String,
    pub url: String,
    pub matched_content: String,
    pub context: String,
    pub severity: u8,
}

/// Main vulnerability matcher for detecting security issues
pub struct VulnerabilityMatcher {
    patterns: Vec<VulnerabilityPattern>,
    compiled_regexes: HashMap<String, Regex>,
}

impl VulnerabilityMatcher {
    /// Create a new VulnerabilityMatcher with default patterns
    pub fn new() -> Self {
        // Define default vulnerability patterns
        let patterns = vec![
            // SQL Injection patterns
            VulnerabilityPattern {
                id: "SQLI-01".to_string(),
                name: "SQL Syntax Error Disclosure".to_string(),
                category: "SQL Injection".to_string(),
                regex_pattern: r"(?i)(sql syntax|sql error|ORA-\d{5}|mysql_fetch_array\(\)|syntax error has occurred|Microsoft OLE DB Provider for SQL Server)".to_string(),
                severity: 4,
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![
                    "documentation".to_string(),
                    "example".to_string(),
                ],
            },
            
            // XSS patterns
            VulnerabilityPattern {
                id: "XSS-01".to_string(),
                name: "Reflected XSS Vulnerability".to_string(),
                category: "Cross-Site Scripting".to_string(),
                regex_pattern: r"(?i)(alert\s*\(|confirm\s*\(|prompt\s*\(|<script>|javascript:)".to_string(),
                severity: 3,
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![
                    "documentation".to_string(),
                    "example".to_string(),
                ],
            },
            
            // Sensitive data exposure
            VulnerabilityPattern {
                id: "EXPOSURE-01".to_string(),
                name: "API Key Exposure".to_string(),
                category: "Sensitive Data Exposure".to_string(),
                regex_pattern: r"(?i)(api_key|apikey|api-key|access_token|secret_key|password)\s*[:=]\s*['\"]([\w\-\.]{10,})['\"]\s*".to_string(),
                severity: 5,
                platforms: vec!["Web".to_string(), "Mobile".to_string()],
                false_positive_checks: vec![
                    "placeholder".to_string(),
                    "example".to_string(),
                    "YOUR_API_KEY".to_string(),
                ],
            },
            
            // Open redirect
            VulnerabilityPattern {
                id: "REDIRECT-01".to_string(),
                name: "Open Redirect Vulnerability".to_string(),
                category: "Open Redirect".to_string(),
                regex_pattern: r"(?i)(redirect|redir|url|link|goto|return_to)\s*=\s*(https?:\/\/|\/\/|\.\.\/|\/)".to_string(),
                severity: 2,
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![],
            },
            
            // Admin interfaces
            VulnerabilityPattern {
                id: "ADMIN-01".to_string(),
                name: "Exposed Admin Interface".to_string(),
                category: "Information Disclosure".to_string(),
                regex_pattern: r"(?i)(admin|administrator|administration|login|backend|cpanel|wp-admin)".to_string(),
                severity: 3,
                platforms: vec!["Web".to_string()],
                false_positive_checks: vec![],
            },
        ];
        
        // Compile regexes
        let mut compiled_regexes = HashMap::new();
        for pattern in &patterns {
            match Regex::new(&pattern.regex_pattern) {
                Ok(regex) => {
                    compiled_regexes.insert(pattern.id.clone(), regex);
                },
                Err(e) => {
                    eprintln!("Failed to compile regex pattern for {}: {}", pattern.id, e);
                }
            }
        }
        
        VulnerabilityMatcher {
            patterns,
            compiled_regexes,
        }
    }

    /// Analyze content for vulnerabilities
    pub fn analyze_content(&self, url: &str, content: &str) -> Vec<VulnerabilityMatch> {
        let mut matches = Vec::new();
        
        for pattern in &self.patterns {
            if let Some(regex) = self.compiled_regexes.get(&pattern.id) {
                for cap in regex.captures_iter(content) {
                    if let Some(matched) = cap.get(0) {
                        // Extract context (text around the match)
                        let match_start = matched.start();
                        let match_end = matched.end();
                        
                        let context_start = match_start.saturating_sub(50);
                        let context_end = (match_end + 50).min(content.len());
                        
                        let context = content[context_start..context_end].to_string();
                        
                        // Check for false positives
                        let is_false_positive = pattern.false_positive_checks.iter()
                            .any(|check| context.to_lowercase().contains(&check.to_lowercase()));
                        
                        if !is_false_positive {
                            matches.push(VulnerabilityMatch {
                                pattern_id: pattern.id.clone(),
                                pattern_name: pattern.name.clone(),
                                url: url.to_string(),
                                matched_content: matched.as_str().to_string(),
                                context,
                                severity: pattern.severity,
                            });
                        }
                    }
                }
            }
        }
        
        matches
    }

    /// Update vulnerability patterns from GitHub
    pub async fn update_patterns_from_github(&mut self) -> Result<(), Box<dyn Error>> {
        println!("Updating vulnerability patterns from GitHub...");
        
        // In a real implementation, this would fetch patterns from a GitHub repository
        // For now, we just return ok
        
        Ok(())
    }

    /// Analyze findings from various sources
    pub async fn analyze_findings(
        &self,
        target: &str,
        dork_results: &[DorkResult],
        shodan_results: &[serde_json::Value],
        urlscan_results: &[serde_json::Value],
        dns_information: &[serde_json::Value],
        js_analysis: &[serde_json::Value],
        cloud_storage: &[serde_json::Value],
    ) -> Result<Vec<Finding>, Box<dyn Error>> {
        println!("Analyzing findings from multiple sources...");
        
        let mut findings = Vec::new();
        
        // Process dork results
        for (i, result) in dork_results.iter().enumerate() {
            // Check URL for vulnerabilities
            if result.url.contains("admin") || 
               result.url.contains("login") || 
               result.url.contains("dashboard") {
                findings.push(Finding {
                    id: format!("FINDING-DORK-URL-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "Exposed Admin Interface".to_string(),
                    severity: "Medium".to_string(),
                    url: Some(result.url.clone()),
                    description: format!("Potential admin interface found: {}", result.url),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: Some(result.found_dork.clone()),
                    screenshot_path: None,
                    has_sensitive_data: false,
                });
            }
            
            // Check snippet for vulnerabilities
            if result.snippet.contains("error") || 
               result.snippet.contains("exception") || 
               result.snippet.contains("SQL syntax") {
                findings.push(Finding {
                    id: format!("FINDING-DORK-SNIPPET-{}", i),
                    target_id: target.to_string(),
                    subdomain_id: None,
                    finding_type: "Error Disclosure".to_string(),
                    severity: "Medium".to_string(),
                    url: Some(result.url.clone()),
                    description: format!("Error message found: {}", result.snippet),
                    discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                    dork_used: Some(result.found_dork.clone()),
                    screenshot_path: None,
                    has_sensitive_data: false,
                });
            }
        }
        
        // Process JavaScript analysis results
        for (i, js_result) in js_analysis.iter().enumerate() {
            // Check for API keys
            if let Some(api_keys) = js_result.get("api_keys").and_then(|k| k.as_array()) {
                if !api_keys.is_empty() {
                    findings.push(Finding {
                        id: format!("FINDING-JS-API-KEYS-{}", i),
                        target_id: target.to_string(),
                        subdomain_id: None,
                        finding_type: "API Key Exposure".to_string(),
                        severity: "High".to_string(),
                        url: js_result.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                        description: format!("API keys found in JavaScript file: {:?}", api_keys),
                        discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                        dork_used: None,
                        screenshot_path: None,
                        has_sensitive_data: true,
                    });
                }
            }
            
            // Check for endpoints
            if let Some(endpoints) = js_result.get("endpoints").and_then(|e| e.as_array()) {
                if !endpoints.is_empty() {
                    findings.push(Finding {
                        id: format!("FINDING-JS-ENDPOINTS-{}", i),
                        target_id: target.to_string(),
                        subdomain_id: None,
                        finding_type: "API Endpoint Disclosure".to_string(),
                        severity: "Low".to_string(),
                        url: js_result.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                        description: format!("API endpoints found in JavaScript file: {:?}", endpoints),
                        discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                        dork_used: None,
                        screenshot_path: None,
                        has_sensitive_data: false,
                    });
                }
            }
        }
        
        // Process Shodan results
        for (i, shodan_result) in shodan_results.iter().enumerate() {
            // Check for vulnerabilities
            if let Some(vulns) = shodan_result.get("vulns").and_then(|v| v.as_object()) {
                if !vulns.is_empty() {
                    findings.push(Finding {
                        id: format!("FINDING-SHODAN-VULNS-{}", i),
                        target_id: target.to_string(),
                        subdomain_id: None,
                        finding_type: "Known Vulnerabilities".to_string(),
                        severity: "High".to_string(),
                        url: shodan_result.get("ip_str").and_then(|ip| ip.as_str()).map(|ip| format!("http://{}", ip)),
                        description: format!("Known vulnerabilities found via Shodan: {:?}", vulns.keys().collect::<Vec<_>>()),
                        discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                        dork_used: None,
                        screenshot_path: None,
                        has_sensitive_data: false,
                    });
                }
            }
            
            // Check for open ports
            if let Some(ports) = shodan_result.get("ports").and_then(|p| p.as_array()) {
                let has_unusual_ports = ports.iter().any(|p| {
                    if let Some(port_num) = p.as_u64() {
                        match port_num {
                            22 | 80 | 443 => false, // Common ports
                            _ => true, // Unusual ports
                        }
                    } else {
                        false
                    }
                });
                
                if has_unusual_ports {
                    findings.push(Finding {
                        id: format!("FINDING-SHODAN-PORTS-{}", i),
                        target_id: target.to_string(),
                        subdomain_id: None,
                        finding_type: "Unusual Open Ports".to_string(),
                        severity: "Medium".to_string(),
                        url: shodan_result.get("ip_str").and_then(|ip| ip.as_str()).map(|ip| format!("http://{}", ip)),
                        description: format!("Unusual open ports found: {:?}", ports),
                        discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                        dork_used: None,
                        screenshot_path: None,
                        has_sensitive_data: false,
                    });
                }
            }
        }
        
        // Process URLScan results
        for (i, urlscan_result) in urlscan_results.iter().enumerate() {
            // Check for security-related headers
            if let Some(page) = urlscan_result.get("page") {
                let missing_security_headers = vec![
                    "Content-Security-Policy",
                    "X-XSS-Protection",
                    "X-Content-Type-Options",
                    "X-Frame-Options",
                ];
                
                let mut missing_headers = Vec::new();
                
                for header in &missing_security_headers {
                    if !page.get(header).is_some() {
                        missing_headers.push(header.to_string());
                    }
                }
                
                if !missing_headers.is_empty() {
                    findings.push(Finding {
                        id: format!("FINDING-URLSCAN-HEADERS-{}", i),
                        target_id: target.to_string(),
                        subdomain_id: None,
                        finding_type: "Missing Security Headers".to_string(),
                        severity: "Low".to_string(),
                        url: page.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                        description: format!("Missing security headers: {:?}", missing_headers),
                        discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                        dork_used: None,
                        screenshot_path: None,
                        has_sensitive_data: false,
                    });
                }
            }
        }
        
        // Process cloud storage findings
        for (i, storage_result) in cloud_storage.iter().enumerate() {
            // All cloud storage findings are potentially sensitive
            findings.push(Finding {
                id: format!("FINDING-CLOUD-STORAGE-{}", i),
                target_id: target.to_string(),
                subdomain_id: None,
                finding_type: "Cloud Storage Exposure".to_string(),
                severity: "Medium".to_string(),
                url: storage_result.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                description: format!(
                    "Exposed cloud storage found: {} ({})", 
                    storage_result.get("title").and_then(|t| t.as_str()).unwrap_or("Unknown"),
                    storage_result.get("storage_type").and_then(|t| t.as_str()).unwrap_or("Unknown")
                ),
                discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                dork_used: None,
                screenshot_path: None,
                has_sensitive_data: true,
            });
        }
        
        // Process DNS information for potential issues
        for (i, dns_result) in dns_information.iter().enumerate() {
            // Check SPF records
            if let Some(records) = dns_result.get("records").and_then(|r| r.as_object()) {
                if let Some(txt_records) = records.get("TXT").and_then(|t| t.as_array()) {
                    let has_spf = txt_records.iter().any(|r| {
                        r.as_str().map_or(false, |s| s.contains("v=spf1"))
                    });
                    
                    if !has_spf {
                        findings.push(Finding {
                            id: format!("FINDING-DNS-SPF-{}", i),
                            target_id: target.to_string(),
                            subdomain_id: None,
                            finding_type: "Missing SPF Record".to_string(),
                            severity: "Low".to_string(),
                            url: None,
                            description: format!(
                                "Domain {} is missing an SPF record, which may lead to email spoofing",
                                dns_result.get("domain").and_then(|d| d.as_str()).unwrap_or(target)
                            ),
                            discovery_timestamp: chrono::Utc::now().timestamp() as u64,
                            dork_used: None,
                            screenshot_path: None,
                            has_sensitive_data: false,
                        });
                    }
                }
            }
        }
        
        println!("Analysis complete. Found {} potential findings", findings.len());
        
        Ok(findings)
    }
}
