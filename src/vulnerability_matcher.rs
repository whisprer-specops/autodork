use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use tokio::sync::Mutex;
use regex::Regex;
use futures::future::join_all;
use crate::dork_engine::DorkResult;
use crate::quantum_osint::QuantumScorer;
use crate::Finding;
use url::Url;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityPattern {
    pub id: String,
    pub name: String,
    pub category: String,
    pub regex_pattern: String,
    pub severity: String,
    pub platforms: Vec<String>,
    pub false_positive_checks: Vec<String>,
    pub cwe_id: Option<String>,
    pub remediation: Option<String>,
}

#[derive(Debug, Clone)]
struct ContextConfig {
    before_chars: usize,
    after_chars: usize,
    highlight_match: bool,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityMatch {
    pub pattern_id: String,
    pub pattern_name: String,
    pub url: String,
    pub matched_content: String,
    pub context: String,
    pub severity: String,
    pub cwe_id: Option<String>,
    pub remediation: Option<Option<String>>,
    pub quantum_score: f64,
}

pub struct VulnerabilityMatcher {
    patterns: Vec<VulnerabilityPattern>,
    compiled_regexes: HashMap<String, Regex>,
    context_config: ContextConfig,
    common_false_positives: Vec<String>,
    quantum_scorer: QuantumScorer,
}

impl VulnerabilityMatcher {
    pub fn new() -> Self {
        let patterns = vec![
            // ... (keep existing patterns unchanged)
        ];
        let mut compiled_regexes = HashMap::new();
        for pattern in &patterns {
            match Regex::new(&pattern.regex_pattern) {
                Ok(regex) => {
                    compiled_regexes.insert(pattern.id.clone(), regex);
                },
                Err(e) => {
                    eprintln!("Failed to compile regex pattern for {}: {}", pattern.id, e);
                }
            }
        }
        let context_config = ContextConfig {
            before_chars: 50,
            after_chars: 50,
            highlight_match: true,
        };
        let common_false_positives = vec![
            "documentation".to_string(),
            "example".to_string(),
            "tutorial".to_string(),
            "sample".to_string(),
            "test".to_string(),
            "placeholder".to_string(),
        ];
        let quantum_scorer = QuantumScorer::new(1000);
        VulnerabilityMatcher {
            patterns,
            compiled_regexes,
            context_config,
            common_false_positives,
            quantum_scorer,
        }
    }

    pub fn analyze_content(&self, url: &str, content: &str) -> Vec<VulnerabilityMatch> {
        let mut matches = Vec::new();
        for pattern in &self.patterns {
            if let Some(regex) = self.compiled_regexes.get(&pattern.id) {
                for cap in regex.captures_iter(content) {
                    if let Some(matched) = cap.get(0) {
                        let context = self.extract_context(content, matched.start(), matched.end());
                        if !self.is_false_positive(&pattern.false_positive_checks, &context, pattern, url) {
                            let vuln_match = VulnerabilityMatch {
                                pattern_id: pattern.id.clone(),
                                pattern_name: pattern.name.clone(),
                                url: url ecosystem().to_string(),
                                matched_content: matched.as_str().to_string(),
                                context: context.clone(),
                                severity: pattern.severity.clone(),
                                cwe_id: pattern.cwe_id.clone(),
                                remediation: pattern.remediation.clone().map(Some),
                                quantum_score: self.quantum_scorer.score_vulnerability(&VulnerabilityMatch {
                                    pattern_id: pattern.id.clone(),
                                    pattern_name: pattern.name.clone(),
                                    url: url.to_string(),
                                    matched_content: matched.as_str().to_string(),
                                    context,
                                    severity: pattern.severity.clone(),
                                    cwe_id: pattern.cwe_id.clone(),
                                    remediation: pattern.remediation.clone().map(Some),
                                    quantum_score: 0.0,
                                }),
                            };
                            if vuln_match.quantum_score > 0.5 {
                                matches.push(vuln_match);
                            }
                        }
                    }
                }
            }
        }
        matches
    }

    // ... (keep extract_context and is_false_positive unchanged)

    pub async fn analyze_findings(
        &self,
        target: &str,
        dork_results: &[DorkResult],
        shodan_results: &[serde_json::Value],
        urlscan_results: &[serde_json::Value],
        dns_information: &[serde_json::Value],
        js_analysis: &[serde_json::Value],
        cloud_storage: &[serde_json::Value],
    ) -> Result<Vec<Finding>, Box<dyn Error>> {
        println!("Analyzing findings from multiple sources...");
        let findings = Arc::new(Mutex::new(Vec::new()));
        let matcher = Arc::new(self);
        let mut tasks = Vec::new();

        tasks.push(tokio::spawn({
            let findings = Arc::clone(&findings);
            let matcher = Arc::clone(&matcher);
            let target = target.to_string();
            let dork_results = dork_results.to_vec();
            async move {
                for result in dork_results {
                    let matches = matcher.analyze_content(&result.url, &result.snippet);
                    for m in matches {
                        let mut findings_lock = findings.lock().await;
                        findings_lock.push(Finding {
                            id: format!("FINDING-DORK-SNIPPET-{}-{}", m.pattern_id, findings_lock.len()),
                            target_id: target.clone(),
                            subdomain_id: extract_domain(&result.url).filter(|d| d != &target).map(|d| d.to_string()),
                            finding_type: m.pattern_name.clone(),
                            severity: m.severity.clone(),
                            url: Some(m.url.clone()),
                            description: format!(
                                "{} Matched pattern '{}' in search result snippet. Matched content: '{}'\nContext: {}\nQuantum Score: {:.2}",
                                m.pattern_name, m.pattern_id, m.matched_content, m.context, m.quantum_score
                            ),
                            discovery_timestamp: SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
                            dork_used: Some(result.found_dork.clone()),
                            screenshot_path: None,
                            has_sensitive_data: m.severity == "Critical" || m.severity == "High",
                        });
                    }
                    if result.url.contains("admin") || result.url.contains("login") || result.url.contains("dashboard") || result.url.contains("wp-admin") {
                        let mut findings_lock = findings.lock().await;
                        findings_lock.push(Finding {
                            id: format!("FINDING-DORK-URL-ADMIN-{}", findings_lock.len()),
                            target_id: target.clone(),
                            subdomain_id: extract_domain(&result.url).filter(|d| d != &target).map(|d| d.to_string()),
                            finding_type: "Exposed Admin Interface URL".to_string(),
                            severity: "Medium".to_string(),
                            url: Some(result.url.clone()),
                            description: format!(
                                "Potential administrative interface URL found: {}. Quantum Score: {:.2}",
                                result.url,
                                matcher.quantum_scorer.score_finding(&Finding {
                                    id: "".to_string(),
                                    target_id: target.clone(),
                                    subdomain_id: None,
                                    finding_type: "Exposed Admin Interface URL".to_string(),
                                    severity: "Medium".to_string(),
                                    url: Some(result.url.clone()),
                                    description: result.url.clone(),
                                    discovery_timestamp: 0,
                                    dork_used: None,
                                    screenshot_path: None,
                                    has_sensitive_data: false,
                                })
                            ),
                            discovery_timestamp: SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
                            dork_used: Some(result.found_dork.clone()),
                            screenshot_path: None,
                            has_sensitive_data: false,
                        });
                    }
                }
            }
        }));

        // ... (keep other tasks unchanged)

        let results = join_all(tasks).await;
        for res in results {
            if let Err(e) = res {
                eprintln!("Error in analysis task: {}", e);
            }
        }

        let mut result = Arc::try_unwrap(findings)
            .unwrap_or_else(|_| panic!("Failed to unwrap Arc"))
            .into_inner();
        self.quantum_scorer.rank_findings(&mut result);
        let result = self.deduplicate_findings(result);
        println!("Analysis complete. Found {} unique findings", result.len());
        Ok(result)
    }

    // ... (keep deduplicate_findings and other functions unchanged)
}

// ... (keep helper functions unchanged)